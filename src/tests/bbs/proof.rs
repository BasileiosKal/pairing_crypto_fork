use super::{
    create_generators_helper,
    test_data::proof::{
        test_data_from_octets_invalid_parameters,
        test_data_proof_gen_invalid_parameters,
        test_data_proof_gen_verify_valid_cases,
        test_data_proof_uniqueness,
        test_data_proof_verify_invalid_parameters,
        test_data_verify_tampered_parameters,
        test_data_verify_tampered_proof,
    },
    EXPECTED_SIGNATURES,
    TEST_HEADER,
    TEST_KEY_GEN_IKM,
    TEST_KEY_INFOS,
};
use crate::{
    bbs::{
        ciphersuites::{
            bls12_381::{get_proof_size, PublicKey, SecretKey},
            bls12_381_g1_shake_256::Bls12381Shake256CipherSuiteParameter,
        },
        core::{
            generator::memory_cached_generator::MemoryCachedGenerators,
            proof::Proof,
            signature::Signature,
            types::{Challenge, FiatShamirProof, Message, ProofMessage},
        },
    },
    curves::bls12_381::{G1Projective, Scalar},
    tests::{
        bbs::{
            get_random_test_key_pair,
            get_random_test_messages,
            get_test_messages,
            TEST_PRESENTATION_HEADER_1,
        },
        mock_rng::MockRng,
    },
    Error,
};
use core::convert::TryFrom;
use ff::Field;
use group::{Curve, Group};
use rand::{prelude::SliceRandom, thread_rng};
use rand_core::OsRng;
use std::collections::{BTreeMap, BTreeSet};

pub(crate) mod test_helper {
    use crate::bbs::{
        ciphersuites::bls12_381_g1_shake_256::Bls12381Shake256CipherSuiteParameter,
        core::{
            generator::Generators,
            types::{Message, ProofMessage},
        },
    };

    use super::*;
    use rand::{CryptoRng, RngCore};

    pub(super) fn to_proof_revealed_messages(
        messages: &Vec<Message>,
        revealed_indices: &BTreeSet<usize>,
    ) -> (Vec<ProofMessage>, BTreeMap<usize, Message>) {
        if revealed_indices.len() > messages.len() {
            panic!("more revealed indices than messages");
        }
        for i in revealed_indices {
            if *i >= messages.len() {
                panic!("index greater than total number of messages");
            }
        }

        let mut proof_messages: Vec<ProofMessage> = Vec::new();
        let mut revealed_messages: BTreeMap<usize, Message> = BTreeMap::new();

        for (i, &m) in messages.iter().enumerate() {
            if revealed_indices.contains(&i) {
                proof_messages.push(ProofMessage::Revealed(m));
                revealed_messages.insert(i, m);
            } else {
                proof_messages.push(ProofMessage::Hidden(m));
            }
        }
        (proof_messages, revealed_messages)
    }

    pub(crate) fn proof_gen<T, R, G>(
        pk: &PublicKey,
        signature: &Signature,
        header: Option<T>,
        ph: Option<T>,
        generators: &G,
        messages: &Vec<Message>,
        revealed_indices: &BTreeSet<usize>,
        rng: R,
        failure_debug_message: &str,
    ) -> (Proof, BTreeMap<usize, Message>)
    where
        T: AsRef<[u8]> + Copy,
        R: RngCore + CryptoRng,
        G: Generators,
    {
        let (proof_messages, revealed_messages) =
            to_proof_revealed_messages(messages, revealed_indices);

        let proof = Proof::new_with_rng::<
            T,
            R,
            G,
            Bls12381Shake256CipherSuiteParameter,
        >(
            pk,
            signature,
            header,
            ph,
            &generators,
            proof_messages.as_slice(),
            rng,
        )
        .expect(&format!(
            "proof generation failed - {failure_debug_message}"
        ));

        (proof, revealed_messages)
    }
}

#[test]
fn debug_display() {
    let mut proof = Proof::default();
    proof.m_hat_list = vec![
        FiatShamirProof(Scalar::zero()),
        FiatShamirProof(Scalar::one()),
    ];

    assert_eq!(format!("{:?}", proof), "Proof { A_prime: G1Projective { x: Fp(0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000), y: Fp(0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000), z: Fp(0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000) }, A_bar: G1Projective { x: Fp(0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000), y: Fp(0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000), z: Fp(0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000) }, D: G1Projective { x: Fp(0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000), y: Fp(0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000), z: Fp(0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000) }, c: Challenge(Scalar(0x0000000000000000000000000000000000000000000000000000000000000000)), e_hat: FiatShamirProof(Scalar(0x0000000000000000000000000000000000000000000000000000000000000000)), r2_hat: FiatShamirProof(Scalar(0x0000000000000000000000000000000000000000000000000000000000000000)), r3_hat: FiatShamirProof(Scalar(0x0000000000000000000000000000000000000000000000000000000000000000)), s_hat: FiatShamirProof(Scalar(0x0000000000000000000000000000000000000000000000000000000000000000)), m_hat_list: [FiatShamirProof(Scalar(0x0000000000000000000000000000000000000000000000000000000000000000)), FiatShamirProof(Scalar(0x0000000000000000000000000000000000000000000000000000000000000001))] }");
    assert_eq!(format!("{}", proof), "Proof(A': 0xc00x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x00, A_bar: 0xc00x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x00, D: 0xc00x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x000x00, c: Scalar(0x0000000000000000000000000000000000000000000000000000000000000000), e^: Scalar(0x0000000000000000000000000000000000000000000000000000000000000000), r2^: Scalar(0x0000000000000000000000000000000000000000000000000000000000000000), r3^: Scalar(0x0000000000000000000000000000000000000000000000000000000000000000), s^: Scalar(0x0000000000000000000000000000000000000000000000000000000000000000), m^_i: [m^_1: Scalar(0x0000000000000000000000000000000000000000000000000000000000000000), m^_2: Scalar(0x0000000000000000000000000000000000000000000000000000000000000001), ])");
}

#[test]
fn default_value_deserialization() {
    let p = Proof::default();
    let bytes = p.to_octets();
    let _ = Proof::from_octets(&bytes)
        .expect_err("default value deserialization should fail");
}

#[test]
fn gen_verify_serde_nominal() {
    const NUM_MESSAGES: usize = 5;
    let messages = get_random_test_messages(NUM_MESSAGES);
    let key_pair = get_random_test_key_pair();
    let header = Some(TEST_HEADER.as_ref());
    let ph = Some(TEST_PRESENTATION_HEADER_1.as_ref());
    let mut generators = create_generators_helper(messages.len());
    let first_and_last_indices_revealed =
        &[0, NUM_MESSAGES - 1].iter().cloned().collect();

    let signature =
        Signature::new::<_, _, _, Bls12381Shake256CipherSuiteParameter>(
            &key_pair.secret_key,
            &key_pair.public_key,
            header,
            &generators,
            &messages,
        )
        .expect("signing failed");
    assert_eq!(
        signature
            .verify::<_, _, _, Bls12381Shake256CipherSuiteParameter>(
                &key_pair.public_key,
                header,
                &generators,
                &messages
            )
            .expect("verification failed"),
        true
    );

    let (proof, revealed_messages) = test_helper::proof_gen(
        &key_pair.public_key,
        &signature,
        header,
        ph,
        &generators,
        &messages,
        first_and_last_indices_revealed,
        &mut OsRng,
        "proof gen failed",
    );
    assert_eq!(
        proof
            .verify::<_, _, Bls12381Shake256CipherSuiteParameter>(
                &key_pair.public_key,
                header,
                ph,
                &mut generators,
                &revealed_messages
            )
            .expect("proof verification failed"),
        true
    );

    let proof_octets = proof.to_octets();
    let proof_deserialized = Proof::from_octets(&proof_octets)
        .expect("roundtrip proof deserialization failed");
    assert_eq!(
        proof, proof_deserialized,
        "proof from roundtrip deserialization doesn't match to original proof"
    );

    assert_eq!(
        proof_deserialized
            .verify::<_, _, Bls12381Shake256CipherSuiteParameter>(
                &key_pair.public_key,
                header,
                ph,
                &mut generators,
                &revealed_messages
            )
            .expect("roundtrip deserialized proof verification failed"),
        true
    );
}

#[test]
fn proof_size() {
    assert_eq!(304, get_proof_size(0));
    assert_eq!(336, get_proof_size(1));
    assert_eq!(368, get_proof_size(2));
    assert_eq!(400, get_proof_size(3));
}

#[test]
fn gen_verify_different_key_pairs() {
    use rand::SeedableRng;
    let mut rng = MockRng::from_seed([1u8; 16]);

    let header = Some(TEST_HEADER.as_ref());
    let ph = Some(TEST_PRESENTATION_HEADER_1.as_ref());
    let messages = get_test_messages();
    let mut generators = create_generators_helper(messages.len());

    let expected_proofs = [
        ["aefcdd877c4a5bb1b013ac28bd4e527f2f9f397eefbe819e6feea49f337032563aacb1bbabf97735ed3c4f4b376f85b78f9c6cb639d2313b29fc990725d9c7f90858b55099bcbd7867225d7f8d55a734825f3c7bd9e1a09f0f276a9c6d5bf2d6a1315878d3a9208e8f58a41aea051cee9bbdd6eeaa42e8dea879b00862685a2e5b41fdc62b3fb2e15bee13047e7fc73460915e6021d6168b19cd639c7f4301ad72430c427dc106dba304a006125a852c1af3d2dad1a9458d79434f539a86a4abe73e03692b8dcf42945963524dcb7ee0078f7aa280318e03a95f017f7880450e7a8307f2a0f63356414c971763409a026b2b0988c39279db51e0f4acfc04a103be89ec7fde7dd2602563551892905cba12101da0ad299f50fd76fbed1a6f6d2b73c78ab8953fce7b0b5e0b594eec426836ef58bfc1c119419c8be560be83bc4d48d084775f29fd379282ebc641df42dd6bed04d453d05bcbd1e533d7be482bc16bdf2081a9967fba9a0077b3d17c74a318695a7ecda4a41f457821407c31f783ddb4ef19b46af98af25a76249894a73a1faf810db15ee062f812f68077f732d82bb442bb626576369c65207fa1de52ab1bbc731080f63e2e55c5e0e5cdf7290d81fc02e57e2e7b7f16ae9da04863a8d544c2b9df8db8dd392dd8635f89bf16e08644d98e6560357e12b02c0111d094f7", "b9d5c9e783c1d8da845975d58d6d93d966d4bf2155022354fb0d955e83b484eccac2c81b91be4e9de68949b1454e92568250d4173ccdc841d99cfd7b89caab29b268f83bfb33269f60a671b243709c5ab010af7a85917c3566ebb939a1457962a560c717b2f37c149f0f10e6b815f6f7d412b447d563c2d93206233cfb936ee8b203ec91bea583c95300d70c0ac45e841b7f752a3c4e6811fbaefbc63f8b505310f01ebec3b34233fbf04343adc12fdb0d81ea058363ef3753ed7b839b360bc7780bf6401ce07755b7fa3594f853cce518f7e97691c6a9f9e1c1b8ff34eddaf87b87597464fd5560fe8d819729a8c70023214a9c8da60d0957ebdfd2b65d7cd7de1f22015c071e92aa54e6d6429543196fc1e92a3da8b9edcc8828e0b0e185bd802b69f5d960f0dc906e0a876fac5dfa261e5d1bbf522c7e0ae6f00fd9b8ae0c25e43d36004b080ee272ecb0784d597d4c6d81ea32fda2f0ed1c5d063ecadd8a38d0594651d05404bf24db49337ce7c4721996fad47ba34b720ab8103323baf0ae8143a957d00d984e72211007cb7a6110cdb10589a8c150c9c31c11caffe408aa64223a461a0f82073bc0fded76442a4fd71798f862a8f53189451875709e7ded9fccdee652f2c54cb6d5bb94317ecf", "84048c482fb7f4835aff49dccb23b1d558ab3bad8e21826d42b23e4035cc4e85dcfc27e230175f998417e50da7d5d59497bde5088533409a35785ad5d009b3c6dc6a8553d7679faf30f4142e09a9eadb7d981d2939ce076053beb3b38cd8bf23831e49a3b6c4b585464740d43a5742ae97a0caa90a11df37cf4700199d8c29d9a3fc8f9b5a63b04a40e653b53c46a7d859285d42129309eb4a5a64bbfffc460cdb35ce95d30b2ab65b72ff124261d37e47073f73324dfb022f1f431abfbf951585e367bd2fa5eead5d6c6f1a78126a2335ab435ae6f4a0e33d00bddcc110c14dcbbd77d36e7a5c863ae9c5f428a5d007280ddfc31d173137a253a396d09ebe7f4f9988cc92264fa769986f0454aa226b55f93aa55c600c201c613f0bae5df2960b49b2df0f01bf0d7d90ed32cc71bf3c41a94b82c52534bbfd42a08220bdf9cc3c77757b07e6e4071a2c873c071ea9a945aa3ec07754b133a03c15349c40d138537f9346d9e5437eb9b8d8a15b1ca63933c213f7c1e65cf6c87332947b6682056bb7fc52840718da6f5b3472ef5ce8d564d7e2df17f971761fee135b80413f91d5afbbfe8429ccda33c24c46ffa68535", "ac5f9751866dcaa2804c6d29f3479e72913aa223a30170f47fd6201a88b1e849b2e38ab6f2b369a981a26e0ecfc5cffcb2a4ed69ac6674b5c599bda3decf5c47c6d39ca9ea584d4b75723bb09a3fb5c3782839d3dc5ad020a185645bcd1f09758dc076aadacdb0c2089fc86c95e61495f4db7fdd0794825febefb7ce21ea8d7756da28a1673317ca5c349e29329e64a25bae5f9ce8406c38fdc658d53e1a398a50b1261e357c91bd8a0392c50de0b580153c37549cce0e259e44371b1f094ad2bb9451f9a874fb20c7f7ecc03bdf3890299d04f43516dfcb39c683b131cebfd3ce1d3570fde79d09473506561650459a02ed89ce1046164d668d591ce05b3a301acb3db07a4881613c5d65390e1b94bd1c99db2adc75936c491f103c5bbbc242b3aeb6351871a6957ab11b5848808f5d1eb1c2942b12cb76a78314477254136607aad3fbe49e79267c6612e378b7bf0633103ddb07c5e6054a95236a59a176728b8fc06a0d532a39c28d223a6220119c0ed83f4f1ce8f1fb6f6dceb9ddf2828f2ce9d32cda72bc7e20a222b135c67c51", "8c4c191aef27d8d57dd9ab376f666ca0ebece7f86e8a3aa251c64c4d539f84af62564fcdd413c4ce97ad20c0f14c06fda83c28229fe3aff71920cbb729286dbb7b07d4a6801e1e44de549f3b6032d244adbf7b55fc8ce29d52107c7f2f24abe1b5b75ee6278a884489602adc5f39d52e9fa2b8e7100b6493e05b374bcf4de85d9d3acd03c2798e5b9664ab60ddd134cd1cd4161df47da32abd5c8c3a1c88b58f42a553e8a3b2fdfe5bec090296bfdcf214af6913a8e33cc919bb0bb1b4ca27b5d8e92c68d2d6026b5ede9e209e4f36ba13bc7a28140a93198f6ccee2ac861f58b23636d5427c063629092ebb7c5580844d52a51dfdc8b6c4505ded15cc6737a75f175d01c73eb925dc5f78e30a7b08721f13d74579795679d38a055e619f2c02485bca470908212d6f7a4a6f816c266b61346eabe7610abc86b8998eeca1f4aae739bcf30e06f64cb7240c3a50d6398301c28cf680219bdfd1e5d67971a36968a08685df7a6a754c0bf3d5454ba72935", "94881c2854bb9692ed0d4a8e5ec7d1877037fec5b4e29d510906152010c39baf9bcbdc87fb18571b3766e1bde74c2c429598e30a3aeee5e5a89992adf78cf66a066bf0d9213727f2b82cfaa2b26557970cd6ce1fe397b9281bb47cd66fe17f67a959a6dbc41545c10c715ab413a0e079693ae1d57335bd358f5addef08fccc64901cec5f68c8d640110524076f6b75583c21616b4f447c66a32bf44c6ac51815029c3f2213dc9cb7dd6167a1971d80f601c7345c277b75da298036ef5d9f2a3a729a2fa4a9a76f8ae04f6698aecd59167246278009c2894a74f513539ef786aa819a657d0517609de8fe6ebd43ef315a302bdd94f28c185813332a03f69cee59c7acd2f4bf35bff75865eeb06ca0260b229d23350457e3e975634d1eed17ce3a0823a9a8413cbcc3bfa9bad0fdfb95e0236a96f54cab7b83c6169a68b1ca7db684426260d2d0af0654875b812315d1db"],
        ["a97570d883e74bc50245a5b3f96937381f6b6c29ca3aa0bb568e2f5a7ff44208b37992741d1d6a37a4c06a457c0ea787a12fdcddd26aaef6fe4cfb67b06072aa66fb756eb4b58782533b9a122e86d84a1fb0d78d76121f026e3c929caaca6d4784c07a32f3a5c911c4c4642b143bc9303ab6ff7b66a1e7286e095156f96b6b84d94c72fe90a52aac6ee13d581a77a4a15c5cd070c3f5dc65fe89791e6d61e471aa53962b3cca58580b4e19bafc5431a74781b2abcefbfe79315d0efcbd631f44997b3e0690924b02229e3f8958d06cd60b4089203590ee9538eadaa3de0fa711ec758cd04a860954ae2ddeb9aa776e610160c32f43f69fa0857ea13a098c8d19926e25486e0f2714f65153153d2692e524c06c73df0c066264f04e966e2b966ce2659a85541cbd4b3bf7d03daaba1375072997a6cd23bb53650355ff6f032c0b90a7733be22438b556e34adfd56ff6376e44a16f9f71fcaaf0efacd7a221bd91cd7a809543f640e632676d1c0840d9365a83c5c07ed6738a2a82c833bcd7644adf3a26d0c4c913cf51e92dcd02055a645dd55f56e1293f210754490200fe2db189fe123807378e30ce4606c6e97e746d204659731f24c37855f19ee8d10d9d050bc2ac7297ee604531ac6f2559f1a37864fae832e2aa482a9902855b6cb2bf1e53305716f674bbb95f34a836e3c55f1a", "b06c95850bf67caa39cc90a3736a7535dd45531045ec27f1b976a2bef6ab762bbef82008b730fa9d4d3d39a9be49d83ca4f8fb75e935899c6eb1b32383a39644f91de4120e2cb8426c414b9e90253a4c79de1a2ae6b60867c40f91c08063dd29a4ea85243173f9b7c77e7e13b1b1aea2b450ea5a1a8e2ecd9dd0d3c6c39449792db7c13a22e2efc6a35ee773e277d8684f238fe9d558763fa3cdd4cc158a8faff527780eb994de9eb7efa71447193e6c246fa8118559f228676444a84c17a785ef73e2514f4dd4fb9da3421b570dc01e0fdda5301020038c3d8193f1ac2b0ecec26890a0c28275da63089436ccc5884f70f15080bb3c1e80b21739be620585bfd53e3d470f711a51436464c10b433bd71824f5ee90d291b12fda26a537436af912b74b258603e0e5e75bd303c3ef8f85038f95c8d9b23ca2acf90e886e05d83c0143f5bb0f1713d443ddc69d1c05ce432765739b3f4d0189865d7c5cf4d90a9f3f32f0fab603385c73f3b670a255b2175f88c048374ade396648f499012aec6b10f99204612d434a00e874d1776b229169ea2ec1022d1c1f3a032264f7d88cfc7253ad0b2fb6fa39377a01d09c634ba836d35234aab70fa4691127470fde9f3e54f853a7c1b69a6cacdbeaa38fb58f41", "8cdfafb772e21c5ec23d811e72709bfd11faacf7b9aae948fec9160deaf83ed65688364b41bc2c8d65a20c0913b36c47a58993c4aba9d34f8df449ee9d73bf7ecf8491fedcc6c849d0d56d79f0aaf8d8523584dd17b920ce5c3ec97d5f9d99b6890ca53b2f82fa6265944bec97939ffb700d53f03029d184fed7bc269bb3bd206569ab326bd32856d71f040b5fc053327378f89071a7ef8357db8ab0c743628d7c1820399884a000ce7009e8070c38281dabc4ff6a1d85ee6f0dce233dd205f662cf3ec92b57dc915ba7efc289c6850926b5ce4d5c1b849f96c1a69f893fa41e730980a133e821189fe6d3fe32b1ad9317b293c377f11432f4267809af9943238d16a6edb309256fa856f3938e0ab0df380a367b5a366b5b82b3265bd8cdc36303f41f37adb90829485eac70caa6caa635f307b2a8a83005aeee7b1f67187744a76972a1096f6a521e3b8957c9b54b5b738123269816026828fd2b97d04c1a63eaf93d9e5a34c5b5f85498adb3f664f359b3fda63063e40146ad662ab9c495d41e25f3fd3466accfaca482aa41e57e70369fe2efec73b86cff4fd098e8b51f68efbd351d021a325eda3790ff6f40c444", "a8778e42c3a1d1917735fccfe2bf994d0c933799e7f10472ebf95a4de754ba762b055928fedb1246b2402427e0f06debaac07953243573c494746a5f2f0f3667f872100b698ffd7e7a1272b3b04e3212c8604285900e0cf29f13cf2369bc3eb6b27da25e133f6b624a916e4ec2bf937c2fe1b7d5c8dc4710dd2efa1c77bff2ec356e3518c5372cf4502792e96a4e48ca460e3e0e2701ca4e839f03200eb598edfc096f599c475cd238cce8cc49658ea929b9b29998c77a2a5d26d674e1f3050427a257f4a1a631e0ad228f19c922fd9b599848261620f7b71e11921458d49b7e0bfffc4c40bb19f2d42168b8f2ca56340a0e490a0f1b2edfa6b19aed13a5b75a002a4e52fe7f88597b8685c2970871bd0205228e75bc32abe3c694803cef7482b96e00284b5a7937f9ccae90fae354871656ce3794c952ef12b3f673e3356e394ee48a977979dff796e58703a93827af1c44353a1636b35015aacfea4d2b87df47464d3d917a7589609440d100f6975045af70740b424a84f0b66705ffe693525fba91d1ba5af70dc0d285b1e52d88c5", "8120c7c357660756812e5a236a785d727ee53c11abbc3f94895ac406bfa1019a65c9d2e635e3bd9828fa22585a513085a52875cea796d8ead2e4cd4ffe7d0dfdb5eb7f6727e155025b9a39055ad3daed5e544457207907a1bac17e36c0b0169bab857d1cc48117e28f3aec79302d8e6f3cabce9ace9f365aca7726a2df35a7e1099469e0638a573cd0b5fbab313705be619c147c4f387b5f1b21c22819d2fc7c221ec806df80f0503115fa24a6338c0c135e7d67df5d345ea449d13b590a8f6f9036b66e7131c2ce16139e4106dea7456da6142996b369ce342501975f58159b20d8e0e61c6585099db299b2869da16c3a79d413f2eaf305b7b2c7fb7556f88a4b56cccf54b831f4cee6d9a9c26c31bd63e61f6f7793e593c52879b1e1d350a084b3b2942a8b39c4eef84f08bf23a98863e19c178238fa5bdacdbbf2697b0fc7de945d25917c9605f93a5bdf0978a51c55747ddc0a32c3845008961743a21d11b17bf1e8b9ea8ac511914245e801c664", "919bfb88c092a8e15c7c3d080e6827e2886110f47e4a09ac2a8939d04eff23fb49614de97370817b97d03a9d06cb5771910a3a604107e2d3ff480a312403db2dcf2852b26448a9a28bff12af9fe78daa4db6c63c8c924b1053a8d5ce4d1c8f01b69262d002bb7db25bf6bf2ba8bccb96edf23564f2a269861d506933a7bc14ade0ba73d8f7117532fadffb0a674cc367082a9264d467ab7cddc34475deedb9b556dcab421669440b1445485d5e92e6af3eb89c0f3cd5ab7230a9aad5bad297513cb5f6c969b46f1aa61cc5d9a485e2bf653108bfc695543fb84d7b6cdaea1553f4cb99a05b2c86db24099f5cb3108292049531338f3cd80bbecfba115f0dcd69bac64dbed312a6695645025bcad92945643e03cde23895b0d2b62cc54311e15ecf17959dae3eb93b41b927a3920d381e6d47c66fa2802724d52ccac4e2b77c1a02dc57561dc13ef1d01a3a209863ea37"],
        ["961fd0fa03c607932d9f87a990af19bd7c6ef45cba1a53e3cf8f5020ff37f1a18ebc2e1c71e50d176bdb03f2fc8480ce88e7d36580352e9f70d5f284f8eae8a78bff58f3c77fbd6729465f7e314bf3facb0b0f69a0b3153ce52a717414cf57ee91389005c54daa59a96a64604c8515210845b6f5c27f43618ffd702c127d3e16bdac359700c740bb0a127bb4238b9c27231ab22444e7892524cd700282865da627006aaa4d4e28cc37d00b6aee7ecb6728a65ea87515c1ea3b38caaa715f15a98e733a8223aab2d791e3a37309c1b0004b294ffe4a9fdd8b1bdd8df7e7dfb34fda8f40fb0642613c969f225ffdabaa2808818a7efb4c7a77d41da430fef65da1b10157d9ec272aef4b14e4b95bf587b871d275002b2532c97c1c592421beea8e9ca48e0a8bf26521d3b7e62d454c568c51cdb8b1837869228d78878b9ce0d1e37fc48d9b39ecbb4c3b1d67bf2d4b7b020e2b0ff00287028e3394fc6386decd3569599e3db29b8ea1e25a2b3b0761ce0f28e9a67af66f89282ec0057f81c06fc6bddffa38d864df3d7eb5f06b87c3e711296fad76dd744402732d4a8999ca3d70b21df9cdbbfdddbb85dd9689f9a32d56710813d6b0f914fcaffcee684ded18419f6670b9ba5905c9d9304d25ae8d7a190c8bc9aefca17597a0cfec8d9cc9fe20b96ed8970c8ce9e3b176f3dff964c761", "b42a9bcc322387252a9d3d4a7843fca9e09927464bc38bf3cf51bd0b1e896029da73157054d90bf9750e2e79375a93e7afa8c7c73dce844ff74a5c9163f884e6de85f59efb10c661f7b662038330e1cb7b3b8e041ea3b6a04d6baf5dc30eb3c3ab807c9a95cee686a59f45834e261e0b7e1812676d728ad211709a49c60f86d2b0d538e2ed2ea39b22eb4555d217f54b4268c993eff3f7d66bc5f1939305b9ca0ddba26e2602e155169190c2b1e25ee864e59ebb9d0233b9b208d96dcca096b6250eb5432d0af9963a98529656217b75725234513fa33bb6cad9c1b0ae6aa653abba45e879a6fc82f0da430d282a4f263645510b35d0d1741d212540024b473445c108769fd91054e23110d110d465382083fd82e6b6da2811267652b95df3b962e2faef6cd2ef18aab702c68d0de8c64064858782bdf938ac6c89a75f467bc002df8f65538d4e2983dad4d08a956a9c73eb9d6de911531e910b80b8d510ec60efee97e796fd3a393d784f4285f141613bdcf736c9de95e1f6766014383e1a97f168a4de7973fc91c47e3243c400bef36ce8dbba00e9d93d0e2c59e92a861c21d7911c8a6876a4fb6ab89bfffeaa06bb3e6aeaf7ed1259a352ac58b198796c30b7b4e602035b6ec982c00602c6173f87", "a19bb1211c588f858a2a0489c846d64cd03c75df6e5e9987ec588a5f2fb673749bc05161c5a9eda9ed8dd3d2ae7c664294c73466158dceb71f5fcb57e046f0d03a8c5b3d4563e46304d41ae40a3ccd4e27d0ee15a40c70747ba5d9927328e2858ee9578ec8734f6d8f09fe6e217bcab559a04cd9b536bd8e49932f44ce8b3b8d28e82f02f583668e18cb684f8abf577f697fe5d12e12839d7fdf09eb678415e27397f80fdc3cf1c8b434d161db1d64be19a417a932419e53e78e8643772955f926c591f2edbcdc35247f87476627e9ae508465ef726919f594a43d43cb3f10adafe328b26422a17ddb3053d86da523a6591c12019d7a8c0fb870dd8bac5cdf555aa36f9d945f4b85a0541489f77ca5c2098a1503b365ef9b90eca409ef44ac4023cce25b6866aa0b9bc211160c1eee8f01ce4d402891165081167789e83de0c811c292cb1f935ec46cf2a3fe59ca18463abbc6472e0f6fbcbac7d0067c198dde7cf0e51bd6f4580c664ab327671d8672481e738118914dd47029e4b59ee1410f373a1fabde9f41a58c926c7a473adb9c67a2a6b4b97e61bad20d1d1589a9f170377665ff2f59381fd2ee12711eef3ab7", "ab97cc4e56d98de8f15ea49708e00d0a041637cd701ae3001375c484277586e67aa5c3220f6509e034e4e5e975f32d5bac94ecc9000b24e41f90e1802f28e25aaf9288a14ae45ab3b881a525e589a78076b12b53b7bc4510a68638fe40303f12838ce3e1eaeee4be4b482166bda0983077ebbeaf9681d80b5653cfd64b3663d6061eff6760751dd5b3e2eac59b71553e1167b56c57f08cb8863dd20a0862a736042be22df9345a979ce33791508c2302070d63cf51d4d276811e3a22c57bb5b48c82c6a92a4df81cad5d0a4246e4da8d44b1607d5ad51a21b50ac9dc849227316211cf6c2ef3c62e086ab1ab31624164737709068eb5111982a4beb25a92fcfe14f2b376c9063b98bc2b1b3ca99af4445351ca23974de2826111560c06016876f964216dacc4c2868141348e23b4cda32eeeb7f0249c9894f06fa3d488afcda9aa8816790605c87214f26cf9947e032f594f7e51cf706b05ba646b63d4914e6c14703e0b13cd345564672ba4098a31300e21b3ccfacedf0ae2378b159bc76037a9e38e848657f17881842774502f7223", "a5724bb0b58a51e81533209bf80d35df3db4167db8b653fe750c0a5f078addf4348a9505b4006b1d4363eda53a16ff6a97e6c61926b7a322f78002abfc23a18e23c5b1ef99e9e296b98550cd7fdd39a5acc4109b0f6a21e66c59de99f2d6ef6786c37e940c2e1782969338515e621afb7b6075d395961f8c9c2adcd65a21300d72d27beaf4cfa09f308fb4c605c8753a71657746a85e7fd9feb95df1220af5766625e5ec4f3253ec61ec9554782060447291e3b929836c3a0c38e728683f760ee7bb36039deda669d504f079b173f5544a816066973a109aea386bc620bea64b34b279a8424078993455a98fd436c9f3274fb5493ee4e60463ec88e29a2208ca066e51e3ea87a2f96d1b03a4ccfb252368ee579c1a67310115f7ab63c97bd5ddcdcc6111671697568874fdedaede4a1733bece4906c74c86ba2a28b5e09f65a70222e8fcd738f1a2f71cdae6fbfaa632195514bb926df12dd322e9dce46bf44fdab6b6f04d4d1f458cc6b9fc584272fa", "91c60ff980a1df17256694cc68a9761ee25b101b461c7a30993e9e2a1d6827329a30d6fbcfd310e0f64e02a2f231e33d8e8c2d3a5cb097752500d0723464316cc69c73d15593ba1c169209c171c17b646319750bde15dde00c51c882ee291940af206ff14c56035748548fb79718ffb5bfc46bcfb19fdb1be9a1ebf057a04427c903f44decee55e8ec590225197b973a3521c30b986ff2825d5a7b948e9442b0a94e2c9ec0d90d3c300edb1869b59b8e3e4640cc3a2dee0dc2a8aff8fbd590bc4a8fb703bffaa35cb626cc5030b078df445944e3f1c26be46cbdabdfbd8aaf8a9e425de15973ab22c373338015dc02ff6e1a41482b5fe228f349a38a08212d89fa9501d99c7f1a65298b23534017922b223aad27df606d97f445fe2623a27b46aade29f3e8eddd4837dca468cc393cb73c5788842903326d5ec6027d8d80d870ecee5882cfb578929d4634c98d64529d"],
        ["93f79bf9dcd288da9287582b9f510fe985f6e3b52c20ed72daa4f36931043faf02abbcc055322f60e279addc477896c884f90fd4d6d8abb5b2b8014c0d60733d6f3eda3214aebee676f7ba798f7676ba9d465dd81aae6e8a889212fc3117d07b8698f6d50315656a2a8054c0a7f9c98a0b61669af9ddb1bb7ac1ff17287ed778e263a88c7335fcb85ad25bcff7c04494685a1f5ca856825fd7e41d6de9ce21971bd8ba1a9d9b82d929cee0b349718efe66dde8cd857e56bfd32383299189f54c8fe3f3e60f7a394d6db3ff752da114863baf606dad26fcdd45320c42bb7803abe299982a2bd0bf429bc015413cd428a7010dd785bfaa1a12407ef58a27a59ff00d024b230c43b6b860dba8239927b4c8575711012b3da6aed04ad7965a9f0658d43a8431e63a59f1da9f2d8fb3d198ff3c3b1e151cf615608ce1e77ff9cb738ae096abe7e7359a1cc43a9328e16d2c9751d4b23e43cc0e31a2259fdb0cebc6f8dba76564e528e201ac14c5789c29cff057171508c9ace4b55510bee0065cd36736f1ab630bd4fba9587ba2f00b1792033160940f88ae7ffc3b3f34848e59388b5678edb454dbd127dd7767562b05e65a39cc24f669e65e5301a01cb8ded184a10935528dd69d6b00453af9af2d77d0c90fe4613f4dcf12ad7dcc89e805900dc143b0f9f7a3edacd2f0a9ab0caae3d91f", "abb775f6ba4731db7f3f1611f8c298ebd6652a50a9471bb02f9b0acc88d4a206eb8f8f6d8b69a4aa513d9b9fe6a93cba88d68ee5cb1e17e042ff3eb843bdad7e999cc4684e832be3c17a5383c92ea2c73cec9c691d92b1b354b073119b108cf48a3862b63dd80500ba43ca691de4309b89d078660159819ca5cd1931776e14e424bd32132351fb8eb9fd35064a2091e4436ce1fd2a5d59f7b4518d3c127ab9885f2f553fa5ffe0899f69351dd5084f552ea97893309a459dcfc2440f6ea85e2e02190377b7aa57495a828e3c9911179d02bc6392a9cf12b21f701a5b768b8543865847f300c0a73b9a55a07865e3d88c3b11a1e2c800786c6bebb440472cab5fd6078255d16c4919d3251160e65e07fc6ea19582f28861df9067c1eb61519e547e01d09e255abdb9047ed77c3d4a60a61ddb6947cf615be1d8e5cac697d4e91e7a98c5324589910d76eb5fc70b97182867ffa5923528a24b862bff70bc9f2f476bc7a88f4ba9b35c81daf2406b2f9b081903d147bb5f09a5d32359e3344a35aeb79932636bb30aeb2ab7ec803b50857e0ec5c66e739946286164db0b7fc6be3a0bf43cab7897332be71a4e3bb3d8442b5d7e8c4fb17c48640f077645e61585d064b83b832e1ff5d8dac29e2947a985e3", "b5385ed8f86b7da852798bdc2727a9b1d577610c887cb498dd6bdc2daf92abf313ac04dc981b48e3d278f861938445109461d84173a970e74b70801e5dc8ec2b7be1004c473d3e265e66f79857dddbb426d58371b046fe4b281ef565ca6e2d6ea54d6f5bcc16b15927b30b2261c65503b07f0e31b42d2855874a3c287811efa4a3b2925c80a62a9ac7f1f2921d01041e70901162bf892e235d35af08cd396a2b17151ac261a039d31891e402b9bc9d8c0d066a5de290bc8167c2536e455c98ad0b80b32f083017554d9889813c2d1bc7187c612616ca05c0827477a5d19264c07ef2b0b8fc00b05fa0d28fba067a27be419f9f1db858a737dfd46d8da23014390544df1ea0d20d903aad278a02202d286819b0c80ba808cef4ae0edb31f29623aa57e8823be0ccca2b7d66bda4119444188bbec7925385f8bba733dda8f1cfc135912abe8f75d3901ec8b24c5aea996e3c78d89626f440e6f5467e67b042b2e3c879cbbe014011db1160b3c3c2a5e0be29f4be77044e2d80e0c0ea6a45f3b2cf6e49f746e47c23c47af9a6624338704d1cf00aaf9d49b2f394c7f900abed087c49713dd0546ca50fc9730ed34826d366", "ae027711a08d2c8aa2bb32d4aa16d8d2c731ff9522492abc2d81e3f3ff93594add5a1c7f1d0c6bc265279e7147b65f29943a590db5761ec9e8d0c06cf56c1e0db2c1b7ef65c9eba08765af76f6279d7bb583b27a6e4aa9e8737e8688fad3de9090f0b611e3fc43a1c5bf25d37adda7142eda516f21576ffe2d21aeca96d7a45be6dc6522b6132a77e4002f7857b5fd684bd5b7cb16c71cbeebda6862f6edfcd91d00fbd610c7d50dc77be0f303ee56666daa76954720c1ece83f2cc427318b067c7c6c5273cc08c5d7103721c9ca103e017b16f77508dfb90986cab295f09ec63169a962855a8be088cbce5baf49d7e06858c7aa757b4d15306b59d67391b6fbc415bb4217d5ccc0804df0a4f8bebb6d52f326bc7a2199117e4bd6c7bc56331bce3b501ac58e6a68acc2f77af6df36a1490fdd65a9f1fe3aec7f5fa8034b82e8b1bae7a6fa18d67ba7f14458efb164c716f220574feae2d82b48c98cd8be302b607cfaeba7383b2e6df7ef95c0a020aa39c5510dbe1b37c443f51892ae62525bf897e51dc8a24d49069462af7c0caeb0", "ac77dafcce3f5faef8cf485f8e255f8848fc5d473973a5bb3ad26dc42afe774c5f913f8bd4fa19a6ba9bc913e01240b5a7d151368c5b7f03fdbf3e25b6113cb9c997857fa3dc129e2ad68f38e83f08237a87eed24ee7dba18fc6ab6789f47a88b756447a23b62e39e9a486ab852a0902d91a6513fee46008f04a20c1e408e01117774ac232af9d2e301900a8e15cba9a6418a87513f92191a71e09e1ae14a47e5b379ea3cf1298fc143498fe2d4acca4331aad668bf274aec53456add1ea168bb41fffc822d31a5a2e5e64c0753e0ee53ea4f81ce3a0d2160da6653832da38c6f89f1b52c2a9e8f5ea97422560f574b7421e1dd6b401162419110e3a525fd15f774cf28acd288ae68ad5184006a324a5592d7e7b89e28d2ee6877719640bab5f2b1ee65275efaacf86b68a3ebf90a4b85b69140e3a2915da0f7e04690de43dd4f5fbc5b8cc6968c63fba046bc469efd553f3437c8e84f909002eb913a55b8e47c60b565911456471b22b81d98a508cc8", "a5987a7981c87763c448f2ba02aa82f3bd91c2933abce387448dc78809a826123dea92cc63cb085069e43f23eaa2df4aad20a91e0c4a395f9f09f6a83e7b96858dbe97e3b3de5539bd6360ba272438eda437ecd7e7a3068d82c1d49b9c979115b5e0f3eee2c47c5f6fd8a3bb5e1f24718422ca6dbdda301e98f2c45205542d4cc59c5586f9c1e10d02ccd0cd28a20b094892397016fa3c89c993f8e85891f2f1e7465f2ecc570a70445d808d4d7edd156389bd886f3d04e0c544596e2b40b11e8f95f1a57403ca1ed8b5b8758001233f3931f6e7b88b9c4786ddef2152d9fe127cccdf739613d2d1113006aeff7410595a2a532b618f08b25c9d091f772cee38f1bf10b3bdda04ea77437f7a65494bf55c25f5d9ead7b93d95f88647a86ae9b3e71d3473ad066d9aa50c6186d21ab9884d82affa91cd054fcacdba74073cfdae7bf96677fc9e77e64ad4f2b8dd86f9ec"],
        ["95aada0d8bfef71ca8d6c4aafb2032d040137a7104d7d50fc2786bcf1ae3ff907c1663280bbece1c8e6da193a38a979a84736edcac51e960aecaab6be410597c254160587beddfbe2cbcd6bca320671611445748b56e0f1f66c4bbf6dfb63f50b27372c2030662e507bfc06185bd17609c0f72503459c77cdf84a483d7ddc934a2e9da21f22e905adff39c148a60547c4127ccf9b918664103f84ebe9b03e50bb9e0e652b89e067f61878860c8c705d46fe59c9207c407227d699f5c072c6d024d9d0a4ca829dcaa5f24048ec40f9b9052cf0ab061a9540592e55c660571136e21b30f63f89ce2b461741e2daf8c269f29c831c6e6fba5c2e3795cccdad1edf597130b9b168b5640eba2b7f6cafe44e9295c387915c81a056495dbcdc9ddab629ba4e53c6bb3bf8a70b05555c68a3650610d2d50734e0c27cabead82ef72b8b828317ada01290d69578fb30ab76aeefc475dbf025bc320bb57958190c28cc992c2d0432dfbe0ab316553c243512803650508763df10d5ace548d55a8de80cadf4be5442eee35f60648b9379ffc76d2c16ecb267039b5763867df7f2c80b21a8e4a024c4160bb4538c1a06cc55287aa732c3d3e0d477e474288791091764dea6303922c347d3b23a87959cf4ed29a872d3a5f66cab90733bd851f6d90a892d92f426528dd2fb3f56e2eb82395b037f4a0", "adec7b1c2adb4900c20dd7d6632bdf92f70b6c9b6a62e775f032d2bb13c60f9b456eb30ead0c2033834237e1704e0273814b75deb715b7526ea90efd7e45c3f91b624964ef138c7eca651f16150583c6fc9f919e295a835d829e15963b51412784e0449cffc4ce7bb7a7c6bb927d51b12671ac0efbb4f8e912d51ac7541aab6886c270e683d63d41932e3a3f66afe09444a39cc311c755144038d0f85366681e4a0dfeaf2b3c72e85c558d04b42635a91feeb5e74ccd8a178c19a58d3a33958817572fb32cbe2d8a9fca84b37bbde37e193564ca84af164b8bca49dabe4c300a13efab1af72c1052ff8b10b0b7668acb507c8d8f590f9d7a44cb142a15f5ba8277a37d709d44d6cdabd4fcf0ea40392c0df2c3ad1e0ab7f147b8d2034127e4d6ced40ba898ba3a99db91a3d2992077f840dfca6a9e8bdbb8c43a236656b5a470cd5519e3822bb25ed2c04d8f90c6fa5107d21206990cb024a7a44ae7dd212f99eb560d6ae2ce560dd28be37023070fa7050d3506edebffd4288926ec7b5c2da24b59a236d67d2a5550d3e69c19e826335d50bbf4f67a811fbc95fb25bb01925d6ee07a1872a16442ebcff3f6175a0435645faa19a5dd9f11c1468ee3fc874a7d0146f979d49937dc7bc542760ad59055", "b8c6c4706a74068f4b101c44144849334fe60e0a64c5875a2a35bb78ebbc3c3c4a19fa8cbdd6c2d848c57a4c2010a996860dd7cdb08e893f418c102514dee44240307c748ec0885bf00fa099f6325a59841b0b839898f340dc1b36d70898bab5b8092bbfaec40be6ccc36a8a41ff77ad817f95c2a0b993543d76c9828f7daf8c9c6173ec212b622909c1340e94ad87ab5179d2ee91568f6aacef0d087ad492ad20fb4f9f730c9c344fc16468f756d40216b534c1ea1592965bd1ad1aafbd5d6cc5427df90ee01c1b0632a3552a1f880069f0ebc28463e7e1957cb90aac04b13534a0844a5aeaa2090c3657d01fcf6365041e8af7aa1b83bcb5517b2b2f005a8636f491655c3fbeb3ce415bc374df19926fe1bc795dba90c638913ff821e2205f3f262b5d8e03887570a6fbc3723aeae16ed49210785e0939cc0e1a32b5ede7722c2b8769047f153b9cc78862c1a9452d70377a681789d1a300ea3dda5ac1190d53a67934cdbde46b44d3caf11d2469242258b5abe71c2ce44ad4f7d381d670207ce517c8d0e54de2542161dfa0a387c03f4557d4e0f10675beeeb722ef32e14f6a527a6e093241d2b64b6a64faf5cbaa", "a0465ccb740b86841bd4c0112ea13ff47ddb6b466886e4fced3f2d192a4fa93a951513e6cfbe3908f8edfeddb15dcfb696122417a88340cd115861b667c7c71a44a20295bfbcdc084abef703521148bbdf9bccf5b6a2422f2eec99b118662d6f99488fae8dcb433094aa231eb8d7d094479c14c52ae42ad24009c348eede530fbb5f091b6ee2dc1b30034899d4c7adfc03fb1338f9380cc94dc6ac5708e0abd1e8ee9bc0d16d139fec4c503c0f8e9721449a86a1a91aef7e7c6e6a1f77bef86e53e4452c5cfb5c5030638a6139253e6c17a1d1d2204424d8b717cef21bba6b897b58dfcf050cf7537ac440f34ceb1565108396aa553d4a4e986eb29c36d8b8fe1cd9d1bb277a2602811bad73b8946e483412c30e56333afe206273018eeccf3387293b12e42fba111b9648f194cbe48813e7f1f02e825a196805d700edc8711f2500c7b83cc976a19d1726090c14e2324467c7e96729f92da63b8f8ad9191aa56b757559d603c7c7861ccc135bb839e06dfc832c5e3c49c7742fac0b7b2937f188bccbf7996374de45d08925b5ab5ea0", "ac8daef60ceb3b31af7c2675d43344f25ece905c5926cbbf529c273ba172bcb39769094d08ac72df3e3c74af332d3a498a77ec721de237efac60e88fa222ca981ddd7bf3efa219be74a59ed4a2fd1e0aec3466c035e5270640be60ac105a53ed86432ff3b41b4846d6685b250c12b276dd95f0ee18ca5cd4b107c57f44f839725465917e1b64e69ee2decb4662734abf73d6f153238dd11541932d0b0362dd631fc8b0908f913eb35444aa9fef90552d2e9497fbaa51bdab33cb48e58187444b69f352a0a4ae59e88b34032430a5530e4d56b30e5f81db6bc51ea6c0cfcb29f322576a2bf243ac05496274ed10644b322183434c9228d3664cd8ff6c4fb2370642ff9cc25b5855b977ccb2733d0220c454005fa77290181f967469eaa18868128d417878837feab114a3ee3680fec7c806a31a9858cc3458efde83f94e13f82bfcff3c7424737fb7a570e852a1120aa83658e82db52620bd60a9d9160f23ef38bb43688a4f24def7700eeb6049805f85", "870b6a1281ff3669ace028bc29051c7b7365fe8f2081ce00ceba862263d9fd9c020b42378b65a58ce175958a94e3c445b1b18f1ceb69b81b16ef8250fcec738761bb0418a761e31d5ee0a172e94e7e404297afbda559e8b7dd81edf33a0fa2dfa9d65a266efb4ca03b4f0e35f7e21015b7c87b3a307b65e6e4cf58655de07a1e4e39a89c7f3c06b1025dfff6351a0242723bd344482ab71dce83b774a6849c630995a86ac37b57a0ebcd87ae3de9e366353b0d620223a9c51e25f69c70987a192b342fad38d2b48abe40ae41709dc05d44b4b63f303aa59c52d83e69c5fe1a95fa8db9c16b7dc0d07081224f873669a7312195b88033d27ddc26a39a1bcb1c6eb72620e02fb251b2a2b231493246defe0289d1ad3c64100bf863aa243527e5b15cbc7256c0a9c8411ddd382c28a6fdda4a7a18884c52210b57c2ae7db7cd0eb0aa536f1c6f905335971bd7bfd1dc39d5"],
        ["a874b5dc3b85a348b792bc9be83bf5d7de5b831c067a968e4c2d321036b234ef523bd0c5168fd1724ea300c152ec7336a1a1878eeb79ec8283dfff74d9782ef0723445492f48271da345225502b0b2bfbf3526359a480a4d181d5f93befc6ced8d6160f9c828d3caa10ae1e6367b6ed2f7bd8a96831ed4441e75eca042bda561a09a964ef60d41cfca0f8a6b55ebba282f1ced7c1ca277767e33738bc45f697a55208762bf7b65742cb845252ed1c1bd4c8d6a86b924be6f4e9c58ec1a627210b38a106d971d6db60ab8b5b4a67d9ef4501b1ba16b2b21d28da1743a59dd3a78b56633d6a7293f57234684fb3d8d23d5645b5264b6d023a9f3154e05ec23b6c932733c2cf4308b279488d2f6f889e950299ccec81773b478cd49f8c2f1046229cc92a30459e055025b52b9e988bbdc13365de8ea58843ee3118f76efbb83b09b32608e904b978a0a910dc6d2f98e804458e41fc0555900f0c5e93d15de498d55efe4f0c894b63a8d13994b8280415814431b25b38fb33e79fdbc3b54bc3de8f331fb875471551a3c071096ae6ca350f50763d066b97a2704ebf54ac2f6165fd9df45c31c2e74f6cd861a29bc9cd89f42687a2445469b970b2b1e22095cf093490afe25f771c014b1486985e2db23a34a13130e3fdb56898dfa9f4a0aa06aed4cd7df42219c214d493ce26daf1a3f3311", "aebc2f489887eb51791859c631e36a6c96dad3d5919a03c12d87dd63cf77dc72090c9cba8d4f7e9bbfa49109297a937aa9b1d10ec87a78f34014f2177feb656dcb9d1e5ac1c0f1b3a66d44ebeb3b8c2175c5423632c8c1172d34e094d742f9d39466841666d9048c3f8799b0404d2c752145ad71cdfee3713eeac71fdf9d4670bf4db1d0a0cb0a2c354b7f8c9aaa16b94db3ac7ebc25124f0f59b0b2ac95cf3482c718bb86d12a26b52f1b8381de336d524126943383005eee283d81d8fb2fb7f95c1ebbbec9b4a67f52c9d3798488ce11ea0ae588a5e2bbf0478658aa9f7f42494ea3092e14b3e44cbca101b097152a4735096a438e6f397c3fb95203f10e6851a83807376e626b92a0c60a1d66419f62807482c17fac87e98abbeccb9b5a4be46760e36164244793b338c825ec7f5a5599b9dc06062a15285f08fa54786eb63e9934400dc9bbb8a6e94752648f46146ffb077916e82c0b4fb0c84cd67587b0dac99e0b185c59c6a0b5ca0d60e06f9141e91c8866f99f7dc8d646d48e19ec9d668d6a20df03b03f4264a8cab9358a9e41752dca1ce4fba2c4f75ea04db3f094e144c89df8f1434c411ce9e48f68563070d215c0c81310e1ad55cf7721fcde73e2ff5646cd805b3b6472c2f488335f5d", "b008164838210e2e864ae26cf29d41dd2091633f25bb9ab1e63e40e9ff88b4e01b9062c48845af1835c8a9f7f6e77a67a7f3c99ecaef1aefb4f8cc55117652551c9809eb882f8eb1ff1ec3f8468f062fefc0568bc2780d87e20feef49e19dceba942d9a6c9552d2388056da074e65a11e5628b4c8cbbc01f490ab47a20caf4df1561644f39f2ddcd9a2e34d17dc7c834288d20863f36d52b2004e3227eef26b1b42fd19d609f3eff487606de7b76f2fe5b94a6d69882897b0ff670b552f7abdaa634871711a43d5eca7c6d3bd449675a27b851aefc009c928c9ce8c225cf53750bd7d218b4e5035027ee330f2fe1b78f638cbef3c41dc0a5bd7a566e4dc284994df55c020384af59477258ea4ab93c0a210ca5f6d0572a9b94b0545064c777a334e01f3cb399d1e44a0161f68aba5c271f70c9b0d344b9f9175bc6d0011613fa49724662be4eab0cb9fc4da61524bb8e09d92b968c5ecf72958f61867abc17000d154fd533db9d70853629eca8bc3fb65caf79b1c1163f41e4f98d7d016eb2fe4b8c3d74e6b4d5ca24bddee0fc662f2f3e89eefc1048ec388c89ecc24ddf2cc48be311a22a1f3fe94d037c9a75991fc2", "9176e593b93df63f9dc6aa16daf72903226f60374964386f941bf6101a1f85127c75051b61daabc3773e67a3ccaa39bab131ce1d1cc1425342f89ef42e33e2302c15d70396a72c3ab94ab2926c56818a0b84e5fc242657ce0c9085ba8b4cec2491adb1996efa8c7ccb154a37fb8706c6d181a99a02afffa0e3013cf5d1942515442253b817882b13c3b8fdd263bdbeb71a04ae8af697bf19db10a23f6df180a1c86401cccd21b4cba2ab68ed3b2f1a4415357dcaff2d36f02a8fc8fee2a0d2b1f3c62e897d1c86725da20cff95ec22ae3f6d4f986d1ee2e0e68a438cab405507442d7f5ff32b382e582f84d92b1b5db400e3da4ebcfd074e4924a14262d72073711c9d853c10d82577a84a6614b20fbc5069418a34c74ac98935d88e6c3b554799cf4e54f7e88640519137c583b68c17348ee51f5f0a2c9a0cbaf84977b3e72d87028e290bcb5f813531ddecf8798ed70bc5e86baeb1d8245285c203c91e4878dac36d1268425823f1c65c0df528e1e65d5a036593b3a5d05493354c7c1fb50961359d3e71d8f38a28e38f864fa76715", "8570d166377788c498743abf78c9b53977ee308764a7b0787a8e68a41f3be485beabcbf4054e7cf3015bbd8e34e4a3d4a3aad9efbbb4dc7442136cf7d3588d6faaa922ff9618271e6062c765e5221ff9d65ca367930fff0f225bfd6c37b217c9b8ba717e359ec95355db435bb506877b4a1e99d2da18757825e36fe4b20138a2a82f1205aedd04fbeb80c6a038a8d3f509f43e4351832bb5b78cdf8ea1cdcd5dac816326b8592037c2fc30c2baa382ca29c588dd05c2cb7bd0aa795089a6ac3416893847403c83178f7e846651a7b4c059eae089c5cb01a4791337fee62371326484ebbff8848f8d2acc42707e53cf355030e168517a56b6a0de1d6ef49ddbab0a8a34fd6621789f53f2ce426eb1bd9c3e8113116e7caf552cb45bdcc06b2ee6d5a10e052f8dc760fdf8718ffd6c408a17144e8ff382c8ed5bf5c7c9eee4a086a1ad1569a5daa12fa0ca1b00346da6f13020b3ae17c1fc9921d596c926e415e65f57721b31b4ae6cc7a0b4cf77767e0c", "986e20e1db090f3205ee9b25905be47c7296c066152e901b80ef3a59e6f7b4fdefe157ef54ab9c62f75c66ce04aa45f3970a1d23efe3fd5e4e30b05aa07efe5cba513c0b81384993694682052ae5829fbc3ed7b36173d39e81fc4808894f00cab3398493391d67524fe2570956fdc44db1568c6bc2f703287b4158931755ff9f2638eeaa193b2af8e8719fbf20896d741f1c7a81426579850fe160f24fc0ee8684c08090e38021c2f73000ba6787a53d2ee5ba11ed6cb8606e5008235a348071884acf14987b9fd7860a50b74725a30901f4ef2b58c43bc75d91b63a8af8155b085fc39aed9209dc5f036de10a05628d23bf89138bda74998012b7d1217674735c9cadcdc6c04f88c9164c36fc10a9a4716ee8267cb3fddc38444af52f8a425e9d72cc8869adeaee4c3a463914da1a574d19e28591768f30b06e54701c0a57af425dd7d904e224bd26bf40c210da0401"],
        ["9447dd19253661e6d44846c20293fd5b6b018a50538a8607ab1d51a93d6d8430fbd42e3fb8e2f58f2002e70c7e22bfb4b669f833b23309da9382b27683b479b209bda47d89f89ac9d59f1505b4fe0f7a0f3d81ecc3f722287d01c29914ce6eb6a93c72c48762cb3da0bd15eff05a277d079a3f40c1e2819eba141891a703db62a9f6640f5b39d29fc270787e6e091f4b23f07aed2fbde204897f1a50ebc25ec22126b85475c3b5818a2613f290b4c3db3e30ba3eebb63bbac3fe06d8a67f6acd6be49748bbbbf5463c945dd71de7fc16435f6618ac3168d36a1bbe76250515b51c4a538915338c066cb9f3d6bdb51069538c3093aed083fb64070f579cf5b5a96059201793c5961264a869c05e81776a28bdfbf0cd0d11cc1514367de7d8e1c1d08c70752d963e3ee2f510d31362cad8454c1900c259ad0263800b4bb911913f99bf4cb4cca32051ad3ddcc518e631443cb6dc09050b8e080e8d3069bf4854cb8292045b437932745af51f5029d853cf155de9c2d0589a077e21c85a625ec19138adeb13112bca6e7fa5d89c818ba58a164d1e4b32d234e43b8c69348e8f1bed0344e6639c51cc68aa6bd2ed5a6121be6f12a4b8305dd5ebfcb3b25a1a8bb69b86f29c6b2564b1614d6774bd5e7798f31e6f2ca3c40dbb027ab112c0398b49dc9c5faec2b3c8164be0dd794253f513b1", "80290e345df7f32d859dab22540ad5619c488c02c0f889d52a6d3da543a1f6c28de34765a6a0dcd8fbcccd34e9d6995c87c47481550264b1e5b57d244285b0ddb95a6eee4cd2b3d67a8ca9253d843b75b172565d71ee6bad858e794cbdc1a178801466edc3be92ef18239c7cad2def728196a0cb6839842948dc20df91367b11a6f7d8b30da527e92c7d377d0536afaa3e330b4978a6a89ff8f6025ca55a3b1b801453d2d19bc65c7f6991ab744c3dcb66cab43dea62ea10a28f55c2c52309e83587d1cc51331f2231fbd8c355e4a0c55e87cd37d8a99897a23321aa1ee5780b823b7fe43cdeb83fe2668e4f3e9ef1284535e32bdc674dc4f63c6e9ff78f9fdc0ae15676f83af836feb4ce293a3cc9681dd61914d2c32892044365c8070cc4f540e0913c9630beabf5fc57c4be651386386a148fa8d0d8383f630f276952ec0238ee76ee2a75fc30f44aed3e7ca5f9f9658f6390c528e6f756c91bb1895eac22adc10e23d555f1c9a8b6f2efa0fdcb152dc0cd8789d8cf445bb4da49e82c4198ff30ffd52fe606193e65a35f844148e915d62e64bfc045c366aac5d97550cd3b3706523f89e0dd12e71067f09b7434900608fa4a1873c17dafcd878da8aa6906a81397f9a5d9d70ceb34f6e0bf85e34f", "82689c6f33505a34ea48724b47d4e90b6a20c1a37217099116d96364748a57964650e64c3f0f228773cfe7caca634cf1a5fe6087aea729c424a0912464b47983268d155535128890dc301e73a0f204d0a57beb1c542933580cef03ee1931f778afbb27350f55455247c391d7ee16b6dfd781ad94caba054b78e3ae67b3cb0a2bea64fb2eac8bf201fd1d7c5f54ac62042a2c99f80c1955ecaba28145a2eb76722d70c67a84a520e20709620e834238a32eca88314b58b00b2964883d469ad7a88f76af1655b5653067f30b206aa575ba05c1d965e0e7ff921f53c3a97dec54e5d24284ef98d083024cbb20fc5aa9e5d833b0f33afc8da2885b9e68ba89237dea28abbdc987b008e72cbbad75676bf0af2a9541dca2706c158ba4d16e0831e6179dc5c3fef3389692b1029c3dab6a42705655b7139e8ef584a63dd4fe2cfd4ffff0d80a470a21be704ff261f92825e17f72cd328938fd0e846fe2d52f45c517577d5551f1809e7e4584a155c81e19f4873077e97b9df2b1c6bcaa3a815de72c435fcc22009abc01d14df7afed52bcfdce4e9a8baa675b863a9fe4f37c297e825a0f4c5e92d05b6ac7aeedeaca1e8c4ef2", "84e84a3bdd974ee1e397c4f39f7649e5b87da518244cb84f6f64c815928b5c2271bbe3b4cfcfa68d676ad91891001c858b4a531c69c4d19dbbf16e96caef94320361dcd732488a3a92f2ecb008db626d2154c6cb53d107d3b58dcdce58ef479ea2b7fcd278222e32063a8d702a79889451533696687210a0e087afccb334c3763533f214dbbf62a67196c518d47cbef6575a3913e442de8cdeaddf56c3efc2b141a03c15670418c41234afb3bb1cdc7c6ecc8227b1492c2a0401a1d86289bdaa8f48825e32da03e9f422c5146d3099f96929abd519dd2fcf5ec998b08bacd9a6b9519e298bbb39d36da14269ec5e01b6595b310007e7e4ff606269e36b2b7dfec5e57f5290cfcd6b21c45a4f0c6f7cb4519fa34d2b6baa37d052056f657f6270cde583a7e0818eb20fde97c1fca5f19d1d54601339ba866788ab6c76d3441be18de3484179c83465a5041ff0f08fc66e1c085b6a4f1619cf84ffd0c51a4af0ac12bb324fb6330f34b55e0f34ec8a6c7827a5d281504fe9304699ceefc2f44c7961c668ebb0b851cee174259061a58d88", "b6de9265ceb6865ef41ee8fef02696aa9a49d8f81937e7177e6bc5414315ddf207e9f02a800e933406eebbd86c36a42db93a9d947aabf26fd0dac513f207202a4edb48d2b041e5c84fb1094be91d695fddb3407f066311907aa621d909881aba8b284c79d77f8ab3b39dca461d00bca952b6c931a6ed7026f1767a5e9cd3ab36492d2757acf978804f65179f85fc281701e1e144c9a3e78600168fd63b19df667a9c51b92667f6bc62d9fc1b5a93b17d275e712c5e08203e00ef2c9c1532ef72e8a34d3bb3f264be33b9155ac582a63952cff4008c031d01394f713b8d16e6f9993da1897e6b493c4cf7a8882fa12327401354ceb92deae4ef328cf6962ff8aad388f6543d1060cc6c0be8ff82db38a71570d2184b19de38cc2e5150104fdbca1240697b63a8c7c53271cf06ad2da7d4543e5563592f8c6909fd22151a94f06c6b44445a336f68870c36d468389726af449152a1dea1a307e92bb38b1482471d3e1c15bcdaa08012148568f446e0dfb7", "ae7c2c873ec92fa3205a0874b827d909c9201145549ed7ffdd6dd3f5d1e85c4320834f19645b2a8d168494507242288490803945a735e7ca6699120b87839b984fe3b5d8963642716afc05e60346a8e19d0d4c2e89905806ff1a00ca162505199016cd847d0228b4a72e53086b11a63a4ba39fb4b56250b39fbddf5dca4afc98b3bf0dffd08871279691ab442873c20c27980d5597614073bb9b04679921e16a067d8a2a98b4bba0130253e4edf5635e602ef502ff3e1e848667a3e03c774fb42851c87b2093a47957b63712da82119947686548b67fbe0b3ce5335beb956aaeb2f21e4040be19531fba7b5c952469fd0c6a45bfb801d50ad25fdf7b9439eaa0f21d38523704e5cc96db6207b7ef51471dc9debb4c5d90b1dcf5e711c1892009d82137586c2449dbd11fd654842facb54c7ff27e5561cb8eafb8479a7ae7fc8b7696949a5a274714bab030ae96b6fc0c"],
    ];

    for i in 0..TEST_KEY_INFOS.len() {
        let pk = PublicKey::from(
            &SecretKey::new(TEST_KEY_GEN_IKM.as_ref(), Some(TEST_KEY_INFOS[i]))
                .expect("secret key generation failed"),
        );

        // start with all hidden messages
        let mut proof_msgs: Vec<ProofMessage> =
            messages.iter().map(|a| ProofMessage::Hidden(*a)).collect();

        let signature = Signature::from_octets(
            &<[u8; Signature::SIZE_BYTES]>::try_from(
                hex::decode(EXPECTED_SIGNATURES[i])
                    .expect("hex decoding failed"),
            )
            .expect("data conversion failed"),
        )
        .expect("signature deserialization failed");
        assert_eq!(
            signature
                .verify::<_, _, _, Bls12381Shake256CipherSuiteParameter>(
                    &pk,
                    header,
                    &generators,
                    &messages
                )
                .unwrap(),
            true
        );

        let mut proof_values: Vec<String> = Vec::new();

        // Reveal 1 message at a time
        for j in 0..proof_msgs.len() {
            let proof = Proof::new_with_rng::<
                _,
                _,
                _,
                Bls12381Shake256CipherSuiteParameter,
            >(
                &pk,
                &signature,
                header,
                ph,
                &generators,
                proof_msgs.as_slice(),
                &mut rng,
            )
            .expect("proof generation failed");

            let expected_proof = hex::decode(expected_proofs[i][j]).expect(
                "expected
             proof test data decoding failed",
            );
            assert_eq!(proof.to_octets(), expected_proof);
            proof_values.push(hex::encode(proof.to_octets()));
            let mut revealed_msgs = BTreeMap::new();
            for k in 0..j {
                revealed_msgs.insert(k, proof_msgs[k].get_message());
            }

            assert_eq!(
                proof
                    .verify::<_, _, Bls12381Shake256CipherSuiteParameter>(
                        &pk,
                        header,
                        ph,
                        &mut generators,
                        &revealed_msgs
                    )
                    .expect("proof verification failed"),
                true
            );
            proof_msgs[j] = ProofMessage::Revealed(messages[j]);
        }
        println!("{:?},", proof_values);
    }
}

// Test generated proof uniqueness although every proof-gen API call uses Rng.
#[test]
fn proof_uniqueness() {
    for (
        (pk1, sig1, h1, ph1, gen1, msg1, revealed_indices1),
        (pk2, sig2, h2, ph2, gen2, msg2, revealed_indices2),
        failure_debug_message,
    ) in test_data_proof_uniqueness()
    {
        let (proof1, _) = test_helper::proof_gen(
            &pk1,
            &sig1,
            h1,
            ph1,
            &gen1,
            &msg1,
            &revealed_indices1,
            &mut OsRng,
            failure_debug_message,
        );
        let (proof2, _) = test_helper::proof_gen(
            &pk2,
            &sig2,
            h2,
            ph2,
            &gen2,
            &msg2,
            &revealed_indices2,
            &mut OsRng,
            failure_debug_message,
        );

        assert_ne!(
            proof1, proof2,
            "proofs should not be equal - {}",
            failure_debug_message
        );
    }
}

#[test]
// Test `Proof::new_with_rng(...)` implementation by passing valid paramter
// values.
fn proof_gen_verify_valid_cases() {
    for (
        (key_pair, header, ph, mut generators, messages),
        failure_debug_message,
    ) in test_data_proof_gen_verify_valid_cases()
    {
        // Signature to be used in proof_gen
        let signature =
            Signature::new::<_, _, _, Bls12381Shake256CipherSuiteParameter>(
                &key_pair.secret_key,
                &key_pair.public_key,
                header,
                &generators,
                messages.clone(),
            )
            .expect("signing failed");

        // Proof gen-verify all hidden messages
        let indices_all_hidden = BTreeSet::<usize>::new();
        let (proof, revealed_messages) = test_helper::proof_gen(
            &key_pair.public_key,
            &signature,
            header,
            ph,
            &generators,
            &messages,
            &indices_all_hidden,
            &mut OsRng,
            failure_debug_message,
        );
        assert_eq!(
            proof
                .verify::<_, _, Bls12381Shake256CipherSuiteParameter>(
                    &key_pair.public_key,
                    header,
                    ph,
                    &mut generators,
                    &revealed_messages
                )
                .expect(&format!(
                    "proof verification failed - {failure_debug_message}"
                )),
            true
        );

        for i in 0..messages.len() {
            let revealed_indices = (0..i)
                .collect::<Vec<usize>>()
                .iter()
                .cloned()
                .collect::<BTreeSet<usize>>();
            let (proof, revealed_messages) = test_helper::proof_gen(
                &key_pair.public_key,
                &signature,
                header,
                ph,
                &generators,
                &messages,
                &revealed_indices,
                &mut OsRng,
                failure_debug_message,
            );
            assert_eq!(
                proof
                    .verify::<_, _, Bls12381Shake256CipherSuiteParameter>(
                        &key_pair.public_key,
                        header,
                        ph,
                        &mut generators,
                        &revealed_messages
                    )
                    .expect(&format!(
                        "proof verification failed - {failure_debug_message}, \
                         revealed indices {revealed_indices:#?}"
                    )),
                true
            );
        }
    }
}

#[test]
// Test proof-verification case with
//    all revealed messages proof value and
//    a `revealed_messages` value where all revealed messages are the original
// messages but those may not be at their original indices
fn proof_gen_verify_all_revealed_shuffled_indices() {
    const NUM_MESSAGES: usize = 5;
    let key_pair = get_random_test_key_pair();
    let header = Some(TEST_HEADER.as_ref());
    let ph = Some(TEST_PRESENTATION_HEADER_1.as_ref());
    let messages = get_random_test_messages(NUM_MESSAGES);
    let mut generators = create_generators_helper(messages.len());

    // Signature to be used in proof_gen
    let signature =
        Signature::new::<_, _, _, Bls12381Shake256CipherSuiteParameter>(
            &key_pair.secret_key,
            &key_pair.public_key,
            header,
            &generators,
            messages.clone(),
        )
        .expect("signing failed");

    // Proof gen-verify all revealed messages
    let indices_all_revealed = (0..NUM_MESSAGES)
        .collect::<Vec<usize>>()
        .iter()
        .cloned()
        .collect::<BTreeSet<usize>>();
    let (proof_all_revealed_messages, _) = test_helper::proof_gen(
        &key_pair.public_key,
        &signature,
        header,
        ph,
        &generators,
        &messages,
        &indices_all_revealed,
        &mut OsRng,
        "proof generation failed",
    );

    // Make a `revealed_messages` value where all revealed messages are the
    // original messages but those may not be at their original indices
    let mut shuffled_messages = messages.clone();
    shuffled_messages.shuffle(&mut thread_rng());

    let revealed_messages_same_but_shuffled_indices = shuffled_messages
        .iter()
        .enumerate()
        .map(|(i, &m)| (i, m))
        .collect::<BTreeMap<usize, Message>>();

    assert_eq!(
        proof_all_revealed_messages
            .verify::<_, _, Bls12381Shake256CipherSuiteParameter>(
                &key_pair.public_key,
                header,
                ph,
                &mut generators,
                &revealed_messages_same_but_shuffled_indices
            )
            .expect("proof-verification should not fail"),
        true
    );
}

#[test]
// `Proof` can be generated with invalid public key but proof verification
// should fail for such proofs.
fn proof_gen_with_invalid_public_key() {
    const NUM_MESSAGES: usize = 5;
    let key_pair = get_random_test_key_pair();
    let header = Some(TEST_HEADER.as_ref());
    let ph = Some(TEST_PRESENTATION_HEADER_1.as_ref());
    let messages = get_random_test_messages(NUM_MESSAGES);
    let mut generators = create_generators_helper(messages.len());
    let indices_all_hidden = BTreeSet::<usize>::new();
    let signature =
        Signature::new::<_, _, _, Bls12381Shake256CipherSuiteParameter>(
            &key_pair.secret_key,
            &key_pair.public_key,
            header,
            &generators,
            messages.clone(),
        )
        .expect("signing failed");

    // Proof is generated by passing invalid PublicKey which is identity element
    let (proof, revealed_messages) = test_helper::proof_gen(
        &PublicKey::default(),
        &signature,
        header,
        ph,
        &generators,
        &messages,
        &indices_all_hidden,
        &mut OsRng,
        "proof generation failed",
    );

    // Proof verification fails with original PublicKey which was used during
    // signing
    assert_eq!(
        proof
            .verify::<_, _, Bls12381Shake256CipherSuiteParameter>(
                &key_pair.public_key,
                header,
                ph,
                &mut generators,
                &revealed_messages
            )
            .expect(&format!("proof verification failed ")),
        false
    );

    // Proof verification also fails if same(or any) invalid PublicKey is
    // provided
    assert_eq!(
        proof.verify::<_, _, Bls12381Shake256CipherSuiteParameter>(
            &PublicKey::default(),
            header,
            ph,
            &mut generators,
            &revealed_messages
        ),
        Err(Error::InvalidPublicKey)
    );
}

#[test]
// Test `Proof::new_with_rng(...)` implementation's returned errors by passing
// invalid paramter values.
fn proof_gen_invalid_parameters() {
    for (
        (pk, signature, header, ph, generators, messages, revealed_indices),
        error,
        failure_debug_message,
    ) in test_data_proof_gen_invalid_parameters()
    {
        let (proof_messages, _) = test_helper::to_proof_revealed_messages(
            &messages,
            &revealed_indices,
        );

        let result = Proof::new::<_, _, Bls12381Shake256CipherSuiteParameter>(
            &pk,
            &signature,
            header,
            ph,
            &generators,
            proof_messages.as_slice(),
        );
        assert_eq!(
            result,
            Err(error),
            "proof-generation should fail - {}",
            failure_debug_message
        );
    }
}

#[test]
// Test `Proof::verify(...)` implementation's returned errors by passing
// invalid paramter values.
fn proof_verify_invalid_parameters() {
    for (
        (proof, pk, header, ph, mut generators, revealed_messages),
        error,
        failure_debug_message,
    ) in test_data_proof_verify_invalid_parameters()
    {
        assert_eq!(
            proof.verify::<_, _, Bls12381Shake256CipherSuiteParameter>(
                &pk,
                header,
                ph,
                &mut generators,
                &revealed_messages
            ),
            Err(error),
            "proof-verification should return error - {}",
            failure_debug_message
        );
    }
}

fn verify_proof_helper<const N: usize>(
    test_data: [(
        (
            Proof,
            PublicKey,
            Option<&'static [u8]>,
            Option<&'static [u8]>,
            MemoryCachedGenerators<Bls12381Shake256CipherSuiteParameter>,
            BTreeMap<usize, Message>,
        ),
        &'static str,
    ); N],
) {
    for (
        (proof, pk, header, ph, mut generators, revealed_messages),
        failure_debug_message,
    ) in test_data
    {
        assert_eq!(
            proof
                .verify::<_, _, Bls12381Shake256CipherSuiteParameter>(
                    &pk,
                    header,
                    ph,
                    &mut generators,
                    &revealed_messages
                )
                .expect(&format!(
                    "proof-verification should not return error - {}",
                    failure_debug_message
                )),
            false,
            "proof-verification should fail - {}",
            failure_debug_message
        );
    }
}

#[test]
// If we pass paramters which were used originally for proof-generation but use
// a modified proof(by modifying `Proof` struct members) in `Proof::verify`,
// verification should fail, i.e. return `false`.
fn verify_tampered_proof() {
    verify_proof_helper(test_data_verify_tampered_proof());
}

#[test]
// If paramters passed to Proof::verify(...) are valid but not the one which
// were used during proof-generation then proof-verification should fail i.e.
// return `false`.
fn verify_tampered_parameters() {
    verify_proof_helper(test_data_verify_tampered_parameters());
}

#[test]
fn to_octets() {
    let a_prime = G1Projective::random(&mut OsRng);
    let a_bar = G1Projective::random(&mut OsRng);
    let d = G1Projective::random(&mut OsRng);
    let c = Challenge(Scalar::random(&mut OsRng));
    let e_hat = FiatShamirProof(Scalar::random(&mut OsRng));
    let r2_hat = FiatShamirProof(Scalar::random(&mut OsRng));
    let r3_hat = FiatShamirProof(Scalar::random(&mut OsRng));
    let s_hat = FiatShamirProof(Scalar::random(&mut OsRng));
    let m_hat_list = vec![FiatShamirProof(Scalar::random(&mut OsRng)); 2];

    let proof = Proof {
        A_prime: a_prime,
        A_bar: a_bar,
        D: d,
        c,
        e_hat,
        r2_hat,
        r3_hat,
        s_hat,
        m_hat_list: m_hat_list.clone(),
    };
    let proof_octets = proof.to_octets();

    let expected_proof_octets = [
        a_prime.to_affine().to_compressed().as_ref(),
        a_bar.to_affine().to_compressed().as_ref(),
        d.to_affine().to_compressed().as_ref(),
        c.0.to_bytes_be().as_ref(),
        e_hat.0.to_bytes_be().as_ref(),
        r2_hat.0.to_bytes_be().as_ref(),
        r3_hat.0.to_bytes_be().as_ref(),
        s_hat.0.to_bytes_be().as_ref(),
        m_hat_list[0].0.to_bytes_be().as_ref(),
        m_hat_list[1].0.to_bytes_be().as_ref(),
    ]
    .concat();
    assert_eq!(proof_octets, expected_proof_octets);
}

#[test]
fn from_octets_invalid_parameters() {
    for (octets, error, failure_debug_message) in
        test_data_from_octets_invalid_parameters()
    {
        let result = Proof::from_octets(octets);
        assert_eq!(
            result,
            Err(error),
            "`Proof::from_octets` should fail - {}",
            failure_debug_message
        );
    }
}

#[test]
fn to_from_octets() {
    let a_prime = G1Projective::random(&mut OsRng);
    let a_bar = G1Projective::random(&mut OsRng);
    let d = G1Projective::random(&mut OsRng);
    let c = Challenge(Scalar::random(&mut OsRng));
    let e_hat = FiatShamirProof(Scalar::random(&mut OsRng));
    let r2_hat = FiatShamirProof(Scalar::random(&mut OsRng));
    let r3_hat = FiatShamirProof(Scalar::random(&mut OsRng));
    let s_hat = FiatShamirProof(Scalar::random(&mut OsRng));
    let m_hat_list = vec![FiatShamirProof(Scalar::random(&mut OsRng)); 2];
    let proof = Proof {
        A_prime: a_prime,
        A_bar: a_bar,
        D: d,
        c,
        e_hat,
        r2_hat,
        r3_hat,
        s_hat,
        m_hat_list: m_hat_list.clone(),
    };

    let proof_octets = proof.to_octets();
    let proof_deserialized = Proof::from_octets(&proof_octets).expect(
        "roundtrip deserialization `Proof::from_octets(...)` should not fail",
    );
    assert_eq!(proof, proof_deserialized);
}
